#!/bin/bash

# let 1 = HeadScript
# let 2 = Flavor
# for each directory in Flavor[.../target?]: directory = module, jsfiles = module[units]
# result: HeadScript.module.unit/module++

# sample: build jCafe from the root directory: bin/build jCafe.js library

localHost=${0%/build}/;
[[ $localHost == "/" ]] && localHost="";

declare -i portLoop=0;

compileOptions="";

while [[ ${1:0:2} == -- ]]; do

  if [[ ${1} == --suite ]]; then
    SuiteOptions="$compileOptions $1 $2"; # compiler default: --suite jCafe
    # this is the jCafe like name, where the modules are installed at runtime.
    # the port function of the compiler uses this for context info on porting.
    shift; continue;
  fi;

  if [[ ${1} == --port ]]; then
    [[ "$2" =~ \:$ ]] || {
      echo "invalid arguments expected /path/to/module: module.path, new.module.path";
      exit 1;
    } >&2;
    [[ "$3" =~ \,$ ]] || {
      echo "invalid arguments expected /path/to/module: module.path.in.file, new.module.path.in.file";
      exit 1;
    } >&2;
    origin="${2/:/}" oldModule="${3/,/}" newModule="$4";
    compileOptions="$SuiteOptions --port $oldModule: $newModule";
    ${localHost}jscompile $compileOptions `${localHost}treecat "$origin" | ${localHost}jsfilter` || {
      echo "failed to jscompile $compileOptions";
    } >&2;
    let portLoop++;
    shift 4;
    compileOptions="$SuiteOptions";
    continue;
  fi;

  if [[ ${1} =~ -(-raw|r) ]]; then
      ${localHost}jscompile --raw "$2";
    shift 2;
    continue;
  fi;
    
  echo "Sorry, i don't know what $1 means" >&2;
  exit 1;
  
done;

((portLoop)) && {
  exit 0;
}

${localHost}jscompile `(echo "$1"; ${localHost}treecat "$2") | ${localHost}jsfilter`

